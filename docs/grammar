
notes:
need to take subshell into account

syntax checks:
valid commands
valid operators
closed quotes
pipeline syntax (do not start and end with | - commands on both sides)
redirection syntax (valid filename after - not used consecutively)
no consecutive operators 

> two cons - end
>> two cons - end
< two cons - end
| two cons - end - begining
can pipe be at the end?

word tokens can be:
                command:
                        simple command: (builtin/shell command)
                                        command with args
                                        command without args
                
                string literals: (things inside '') any character
                variables (expandables): 
                filenames: alpha - digit - . 


/* grammar symbols */
%token TOKEN_WORD 
%token TOKEN_WHITESPACE
%token TOKEN_OP_REDIRECTION_OUT
%token TOKEN_OP_REDIRECTION_IN
%token TOKEN_OP_REDIRECTION_APPEND
%token TOKEN_OP_PIPE '|'
%token TOKEN_UNKNOWN


/* building blocks */
<alpha> ::= [a-z][A-Z]
<digit> ::= [0-9]
<metacharacter> ::= '|' '<' '>' '>>' <separator>
<separator> ::= '\t' ' ' '\n'
<whitespace> ::= ' ' '\n' '\t' '\v' '\f' '\r'
<operator> ::= '|' '>' '<' '>>' 
<filename chars> ::= '.' 
<word> ::= !<metacharacter>


/*expandables*/
<variable> ::=   <word>
            |   '_' <word>
            |   <variable> <digit>
            |   
/*dont start with digit
end with digit okay
start with _ okay
cant be enclosed in paran
no special characters ! &  ? @ 
no dot in the middle - start - 
weird case:
    $ echo $value[h]
    $ hi[h]
*/

<filename> ::=  <word>



<io_redirect> ::=   <io_file>
                |   <io_here>

<io_file> ::= '<' <filename>
            | '>' <filename>
            | '>>' <filename>


<io_here> ::= '<<' <here_end>
            | '<<-' <here_end>

here_end ::= <word>




<simple_command> ::=    <cmd_prefix> <cmd_word> <cmd_suffix>
                |  cmd_prefix cmd_word
                |  cmd_prefix
                |  cmd_name cmd_suffix
                |  cmd_name

<cmd_name> ::= <word>

<cmd_word> ::= <word>


<cmd_prefix> ::=  <io_redirect>
            |   <cmd_prefix> <io_redirect>


<cmd_suffix> ::=    <io_redirect>
            |   <cmd_suffix> <io_redirect>
            |   <word>
            |   <cmd_suffix> <word>


<pipeline> ::= <simple_command>
            | <pipeline> '|' <simple_command>








Sematic rules:
commands be valid and executable
command arguments be valid
files exist and have correct permission

draw examples of how a sequence of commands, pipeline, etc is going to be parsed into a tree
        pipe
      /     \
   cmd       cmd
   /   \      /  \
echo  hello  grep  elo
/
-n


                REDIR_OUT
               /         \
            pipe       outfile
             /     \
            /      cmd 
           /      /   \
          /      grep  6 
      pipe
      /     \
   cmd       cmd
   /   \      /  \
echo  hello  wc  -l



       pipe
      /     \
    cmd       cmd
    /   \      /  \
echo  hello  wc    -l
             /
          pipe
          /  \
      grep   6
echo hello | wc -l | grep 6 > outfile


